\documentclass[a4paper]{scrreprt}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\usepackage[german,linesnumbered,algoruled,longend,vlined]{algorithm2e}
\DontPrintSemicolon
\SetArgSty{}
\SetKw{KwOr}{or}
\SetKw{KwAnd}{and}
\SetKw{KwNot}{not}
\setlength{\algomargin}{3ex}

\usepackage[fixlanguage]{babelbib}
% \selectlanguage{ngerman}
\setbibliographyfont{title}{}
\setbibliographyfont{jtitle}{}
\setbibliographyfont{btitle}{\emph}
\setbibliographyfont{stitle}{\emph}
\setbibliographyfont{journal}{\emph}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{graphicx}
\usepackage[bookmarks,bookmarksnumbered]{hyperref}
\usepackage[font=small,format=hang,labelfont=bf,figurename=Abb.,tablename=Tab.]{caption}
\usepackage{subcaption}
\usepackage{enumerate}
\usepackage{textcomp}

\newtheorem{satz}{Satz}[chapter]
\newtheorem{lemma}[satz]{Lemma}
\newtheorem{beobachtung}[satz]{Beobachtung}
\newtheorem{folgerung}[satz]{Folgerung}
\newtheorem{korollar}[satz]{Korollar}
\theoremstyle{definition}
\newtheorem{definition}[satz]{Definition}
\newenvironment{beweis}{\begin{proof}}{\end{proof}}

\graphicspath{{abbildungen/}}

% Eigene Commands:
\newcommand{\go}{glatt-or\-tho\-go\-nal}
\newcommand{\Go}{Glatt-or\-tho\-go\-nal}
\newcommand{\Epsilon}{\mathcal{E}}
\newcommand{\N}{\mathbb{N}}
\newtheorem{example}[satz]{Beispiel}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%% Bitte nur ab hier Änderungen vornehmen %%%%%%%%%%%%%%%%%%%%%

%% hier Titel und Autorennamen eintragen

\subject{Bachelorarbeit}
\title{Implementierung eines Algorithmus\\ für das glatt-orthogonale Zeichnen \\ planarer Graphen} % Geben Sie hier den Titel Ihrer Arbeit an.
\author{Bernhard Häussner} % Geben Sie Ihren Namen an. 
\date{Eingereicht am 14. April 2014 \\ Version \today} % TODO: Geben Sie das Abgabedatum an, entfernen Sie das Versionsdatum
\titlehead{Julius-Maximilians-Universität Würzburg\\
Institut für Informatik\\
Lehrstuhl für Informatik I\\
Effiziente Algorithmen und wissensbasierte Systeme}
\publishers{Betreuer:\\
Prof.\ Dr.\ Alexander Wolff\\
Dipl.-Inf.\ Philipp Kindermann} % Geben Sie den Namen des weiteren Betreuers and
\maketitle
\tableofcontents







% TODO: Was ist das: ? Datenstrukturen, Testdaten, Probleme

\chapter{Einleitung}
\label{chap:intro}

Das automatisierte Zeichnen von Graphen stellt eine Vielzahl von Herausforderungen. 
Eine Herangehensweise ist es, zunächst einfachere oder speziellere Graphen zu zeichnen. 
Dazu Teilt man die Graphen in Klassen ein, die eine Aussage machen über die Schwierigkeit, den Graphen zu zeichnen. 
In dieser Arbeit geht es um die Klasse der planaren Graphen. Sie zeichnen sich dadurch aus, dass sie sich ohne Kantenüberschneidung in einer Ebene zeichnen und sie haben nur polynomial viele Kanten. 

Eine Anwendung des  automatisierte Zeichnens planarer Graphen ist die computergestützte Erstellung von Layouts für Schaltkreis-Platinen. Hierbei werden Komponenten, wie integrierte Schaltkreise (Chips), als Knoten modelliert und die verbindenden Leiter als Kanten. Da die Leiter im Herstellungsprozesses  aus technischen Überlegungen nur entweder horizontal oder vertikal auf einem Gitter verlaufen können, beschränkt man sich hier auf orthogonale Layouts. Bei solchen orthogonalen Zeichnungen planarer Graphen können nur 4~Kanten je Knoten ohne Überdeckungen verbunden werden. Man nennt diese vier möglichen Richtungen Ports. Die Graphen, die sich so zeichnen lassen gehören zu der Klasse der 4"~planaren Graphen: planare Graphen, deren maximaler Kontengrad~4 ist. Abhängig von der maximalen Anzahl~$k$ der Segmente in einer Kante in einem Layout, teilen wir es in die Klasse $OC_k$ ein.

Orthogonale Layouts wurden in der Vergangenheit auch aufgrund ihrer Praxisrelevanz stark verbessert. Sie sind zur Visualisierung von Graphen für Menschen (etwa für abstrahierte ÖPNV-Netze, Organigramme, UML-Diagramme) jedoch nur schlecht geeignet, da sie schnell unübersichtlich wirken. % TODO: Quelle?, Roberts et al.?
Natürlich kann Übersichtlichkeit nicht genau definiert werden; jedoch werden die harten 90\textdegree-Knicke in den Kanten, an denen sich horizontale und vertikale Abschnitte treffen, leicht mit Knotenpunkten verwechselt. Auch wirken sie eher technisch und deshalb für bestimmte Zielgruppen wenig ansprechend.

Um dieses Problem zu lösen, glättet man die Knicke mit Kreisbögen. Man redet dann von glatt-orthogonalen Zeichnungen. Die Kreisbögen gehen tangential in die orthogonal verlaufenden geraden Abschnitte über. Die entstehenden Zeichnungen wirken übersichtlich, freundlich und ästhetisch, was für ansprechende Visualisierungen förderlich ist. Dadurch, dass die Kanten ansonsten trotzdem orthogonal verlaufen, bleibt die Komplexität der Layouts vergleichsweise gering. Man vergleiche hierzu etwa die in Handarbeit gefertigten Soziogramme des Künstlers Mark Lombardi (1951--2000), die u.a. aufgrund ihrer Runden Kanten eine gewisse Ästhetik erreichen, jedoch mangels orthogonaler Gitterstruktur wenig Systematik erkennen lassen. 

Bestehende Algorithmen zur automatisierten Erstellung glatt-orthogonaler Zeichnungen bauen auf bewährten Algorithmen für orthogonale Zeichnungen auf und erweitern diese so, dass genügend Platz für die abgerundeten Kanten bleibt, ohne dabei Kantenüberschneidungen einzuführen. Als Grundlage wählt man Algorithmen, welche die Anzahl der Knicke (auch pro Kante) in der entstehenden Zeichnung klein halten. 

Dabei müssen neue Herausforderungen angegangen werden. Ebenso wie Knicke in orthogonalen Zeichnungen für erhöhte Komplexität sorgen, sind in glatt-orthogonalen Zeichnungen Wechsel zwischen geraden und gekrümmten Abschnitten und zwischen Abschnitten aus Bögen mit unterschiedlichen Radien zu vermeiden. Gleichzeitig sollte die Fläche der Zeichnung nicht zu groß werden.

Es wäre trivial möglich, alle Kanten abzurunden, indem man Kreisbögen mit dem Radius der Gittergröße einfügt. So würden neben den Kreisbögen gerade Stücke über bleiben. Daher versucht man die Kreisbögen größer zu machen und so geschickt anzuordnen, dass möglichst wenige Wechsel zwischen verschiedenen Segmenten benötigt werden. Wir teilen die glatt-orthogonalen Zeichnungen in Abhängigkeit der maximalen Anzahl~$k$ von Segmenten in einer Kante in die Klasse $SC_k$ ein. 

\section{Ziel}

Mit dieser Arbeit habe ich mir nun zur Aufgabe gemacht, einen solchen Algorithmus zum Erstellen glatt-orthogonaler Zeichnungen zunächst zu implementieren. Dazu werde ich den Algorithmus zunächst verständlich und so vollständig wie nötig erklären, um die zukünftige Verwendung von Verbesserung zu erleichtern. Damit der Leser ein umfassendes Bild des Algorithmus vermittelt bekommt, wird auch der Ausgangs-Algorithmus für orthogonale Layouts erklärt, sowie einige Hilfsroutinen. 

Die Implementierung ermöglicht es, für eine Reihe von Beispielgraphen \go e Layouts zu erstellen. Diese sollen die Nützlichkeit von glatt-orthogonalen Layouts unterstreichen und als Inspiration für die praktische Anwendung des Algorithmus dienen.

Dabei werden eventuelle Probleme aufgezeigt, die wiederum als Grundlage zur Verbesserung des Algorithmus dienen. 

\section{Struktur}


Der verwendete Algorithmus wird in Alam et al.~\cite{smooth-13} beschrieben. Er basiert auf orthogonalen
Layouts, welche mit dem Algorithmus von Biedl und Kant~\cite{biedl+kant-98} bzw. Liu et al.~\cite{liu+etal-98} erstellt
werden.

Diese Algorithmen werden zunächst noch einmal in ihrer Gesamtheit erklärt. Dabei werden die
verwendeten Definitionen genannt und die Notationen eingeführt. Die nötigen Datenstrukturen
werden konkretisiert und gelöste Teilprobleme erörtert. Daraufhin wird auf die Implementierung eingegangen und welche Besonderheiten sowie Herausforderungen hierbei zu
beachten waren. 

Im Anschluss wird die Implementierung mit verschiedenen Testdatensätzen kontrolliert. Anhand
der Ausgaben auf den Testdaten werden Schwachstellen des Verfahren identifiziert. 
Zuletzt werden noch einige Verbesserungsmöglichkeiten diskutiert, wie das Ergebnis
optimiert werden kann, im Hinblick auf Komplexität und Platzbedarf.

% TODO: Verweise auf Abschnitte, jeweils NACH der Beschreibung des Abschnitts







\chapter{Grundlegendes}
\label{chap:basics}

In diesem Abschnitt sollen einige Grundlagen definiert werden. Zu jedem Begriff gibt es eine knappe Definition und einige Anmerkungen zur Relevanz für den Algorithmus. So wird die Problemstellung im Verlauf dieses Abschnittes immer klarer und im nächsten Abschnitt kann der Algorithmus mit den definierten Grundlagen präzise beschrieben werden.

\section{Graphen}

Zunächst sollte natürlich definiert werden, was überhaupt visualisiert werden soll:

\begin{definition}
  Ein \emph{(ungerichteter) Graph} $G$ ist ein Tupel $(V, E)$ von Mengen, wobei $E \subset \mathcal{P}(V)$.
  Die $v \in V$ heißen \emph{Knoten}, die $e \in E$ \emph{Kanten}.
\end{definition}

Graphen bilden die Eingabe für die Zeichenalgorithmen. Die hier behandelten Graphen beschreiben Verbindungen zwischen Elementen als Kanten zwischen Knoten. 

\begin{example}
  \label{ex:graph}

Der Graph $G_\text{E}$, an dem fortan verschiedene Konzepte illustriert werden, ist definiert durch:

\[G_\text{E} = (V_\text{E}, E_\text{E})\]
\[V_\text{E} = \{0, 1, 2, 3, 4\}\]
\[E_\text{E} = \{\{0, 1\}, \{0, 2\}, \{0, 4\}, \{1, 2\}, \{1, 4\}, \{2, 3\}, \{3, 4\}\}\]

Hier wären 1, 2 und 3 Beispiele für Knoten und $\{0, 1\}$ wäre eine Kante.
\end{example}

Zunächst liegt der Fokus auf ungerichteten einfachen Graphen, das bedeutet, es gibt zwischen zwei Knoten jeweils nur höchstens eine Kante und eine \emph{Schleife}, also eine Kante mit $|e| = 1$ kommt nicht vor.

Einfache Graphen können im Computer als \emph{Adjazenzmatrix} $(a_{i,j})$ dargestellt werden, mit $a_{i,j} = 1$ falls $\{v_i, v_j\} \in E$ und $0$ sonst. Hier wird jedoch $O(|V|^2)$ Speicherplatz verwendet. Für Graphen mit vergleichsweise wenigen Kanten eignet sich die Darstellung als \emph{Adjazenzliste} $A$ mit $A(v) = \{e \in E | v \in e\}$. Hierfür wird $O(|V| + |E|)$ Speicher benötigt. Im Graphen $G_\text{E}$ wäre z.B. $A(3) = \{2,4\}$. % TODO: Speicher genau Checken!!!

\section{Orthogonale Visualisierungen von Graphen}
\label{sec:orthogonalDrawings}

\begin{figure}[h]
        \centering
        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=0.6\textwidth]{exampleA/straightline}
                \caption{Ohne Überschneidungen.}
                \label{fig:exampleAstraightline}
        \end{subfigure}
        \quad
        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=0.52\textwidth]{exampleA/straightlineNonplanar}
                \caption{Mit Überschneidungen.}
                \label{fig:exampleAstraightlineNonplanar}
        \end{subfigure}
        \caption{Zwei Zeichnungen des Graphen $G_\text{E}$ aus Beispiel~\ref{ex:graph}. Zur besseren Übersicht sind die Knoten mit \emph{V} und ihrer Nummer beschriftet.}
\end{figure}


Die Darstellung von einfachen Graphen für Menschen, die \emph{Zeichnung} oder \emph{Visualisierung}, besteht üblicherweise aus Punkten, also kleinen Kreisen, für jeden Knoten und Verbindungslinien für die Kanten. Die Überführung von einer Adjazenzliste in einer solche Darstellung nennt man das \emph{Zeichnen} von Graphen. Hierfür gibt es keine kanonische Vorgehensweise. Der umgekehrte Weg von der Zeichnung zur Adjazenzliste jedoch ist (bei geeigneten Zeichnungen) eindeutig und trivial zu lösen.

Eine Zeichnung des Beispielgraphen $G_\text{E}$ findet sich in Abbildung~\ref{fig:exampleAstraightline}.

Für \emph{Multigraphen} mit mehreren Kanten zwischen zwei Knoten kommen Variationen der Zeichnungen für einfache Graphen in Frage, die solche Kanten als Bündel oder dicker darstellen. Sie sollen daher hier nicht behandelt werden und einfache Graphen werden im Folgenden kurz als Graphen bezeichnet.

\begin{figure}[h]
  \centering
  \includegraphics{koordinatengitter}
  \caption{Gezeichnet wird in eine Koordinatenebene. Hier wird die Anordnung der beiden Koordinaten-Achsen gezeigt, die Richtungen der Ports $\{\text{L, R, T, B}\}$, der Drehsinn der Anordnung im Uhrzeigersinn der Adjazenzlisten und die Quadranten $\{\text{I, II, III, IV}\}$.}
  \label{fig:coords}
\end{figure}

\begin{definition}
  Ein (zweidimensionales) \emph{Layout} $L$ über einer Menge $V$ ist eine Abbildung $L_V : V \to \N \times \N $. Ein \emph{Port} p ist eine Element der Menge \{\text{L, R, T, B}\}. Eine \emph{Portzuweisung} $P$ ist eine Abbildung $P: \{(v, e) \in V \times E | v \in e\} \to \{\text{L, R, T, B}\}$. Ein \emph{orhogonales Layout} ist ein 3"~Tupel $(L_V,L_E,P)$ von Layouts $L_V$ und $L_E$ und einer Portzuweisung $P$.
\end{definition}

Die Hauptaufgabe eines Zeichenalgorithmus ist die Positionierung der Knoten auf einer Zeichenebene. Die berechnete Positionszuweisung heißt Layout. In einer \emph{geradlinigen Zeichnung} werden die Kanten als gerade Linien zwischen den Knoten gezeichnet. Hier bestimmt also die Position der Knoten vollständig das Aussehen der Kanten.

Bei orthogonalen Zeichnungen bestehen die Kanten aus horizontalen und vertikalen Segmenten entlang des Koordinatengitters der Zeichenebene. Zwei verschiedene orthogonale Zeichnungen des Beispielgraphen $G_\text{E}$ finden sich in Abbildung~\ref{fig:exampleAorthogonal}.

\begin{figure}[h]
  \centering
\begin{subfigure}[b]{0.4\textwidth}
  \centering
  \includegraphics{exampleA/orthogonalNocompress}
  \caption{Mit stufenförmiger Kante $\{0,4\}$.}
  \label{fig:exampleAorthogonalNocompress}
\end{subfigure}
  \quad
\begin{subfigure}[b]{0.4\textwidth}
  \centering
  \includegraphics{exampleA/orthogonalCompress}
  \caption{Ohne stufenförmige Kanten.}
  \label{fig:exampleAorthogonalCompress}
\end{subfigure}

  \caption{Der Graph $G_\text{E}$ aus Beispiel~\ref{ex:graph} in orthogonalen Zeichnungen.}
  \label{fig:exampleAorthogonal}
\end{figure}

Bei orthogonalen Zeichnungen gibt es eine Vielzahl von Möglichkeiten für das Aussehen der Kanten: An den Gitterpunkten kann entweder zuerst horizontal oder zunächst vertikal weiter gezeichnet werden. Wird immer abwechselnd horizontal und vertikal gezeichnet, entstehen viele Knicke in den Kanten. Man gibt die \emph{Komplexität} einer orthogonalen Zeichnung in Abhängigkeit der größten Anzahl von Segmenten $k$ in einer Kante dieser Zeichnung an, und nennt sie dann eine \emph{$\text{OC}_k$-Zeichnung}. Die Abbildung~\ref{fig:exampleAorthogonal} enthält somit zwei OC$_3$-Zeichnungen, da die Kante $\{0,4\}$ jeweils aus drei Segmenten besteht.

Eine Möglichkeit, das Aussehen der zu normieren und gleichzeitig die Anzahl der Knicke zu minimieren, wäre es, immer zunächst den vollständigen horizontalen Weg am unteren Knoten und dann den vertikalen Weg nach oben zu zeichnen, sodass jede Kante L"~förmig ist. Hierbei kommt es jedoch zu Überschneidungen, wenn beispielsweise zwei Kanten einen Knoten in die selbe Richtung verlassen. Überschneidungen sorgen für Zweideutigkeiten in der Zeichnung und sollen vermieden werden. Deshalb weißt man den Kanten an jedem Knoten einen Port aus der Menge $\{\text{L, R, T, B}\}$, also Links, Rechts, Top (oben) oder Bottom (unten) zu. Die Richtungen der Ports sind auch in Abbildung~\ref{fig:coords} zu erkennen.
\\

Das Zeichnen einer Kante $e$ eines Graphen $G = (V,E)$ in einem orthogonalen Layout $(L_V,L_E,P)$ kann nun so erfolgen: Von den von $L_V$ gegebenen Positionen der beiden Endknoten $v \in e$ wird eine Gittereinheit in der Richtung des Ports gezeichnet. Von diesen Positionen aus wird eine horizontale Linie bis zur x"~Koordinate des von $L_E$ gegebenen Kantenorts gezeichnet. Die beiden Endpositionen werden mit einer vertikalen Linie verbunden. %% TODO: Proof?
\\

Es können jedoch immer noch Überschneidungen von Kanten an einem Knoten $v \in V$ auftreten, wenn die Ports kollidieren, wenn es also zwei Kanten $e_1, e_2 \in E$ mit $P(v, e_1) = P(v, e_2)$ gibt. Da es nur vier Ports gibt, können somit nur maximal vier Kanten mit einem Knoten verbunden sein.

\begin{definition}
  Die Anzahl $deg(v) = |\{e \in E | v \in e\}|$ ist der \emph{Grad} eines Knotens. Der Wert $deg(G) = \max_{v \in V}{deg(v)}$ eines Graphen $G = (V, E)$ ist der Grad des Graphen.
\end{definition}

Im Beispielgraphen $G_\text{E}$ wäre $deg(G) = 4$ und $deg(0) = 3$, $deg(1) = 3$, $deg(2) = 4$, $deg(3) = 2$, sowie $deg(4) = 4$.

Zum Beispiel w %%%%%%%%%%%%%%%%%%%%%%%

Ohne Kanten-Überschneidungen an den Knoten können also nur Graphen mit Maximalgrad~4 gezeichnet werden. 

Es kann noch immer Überschneidungen bzw. Kreuzungen der Kanten an anderer Stelle geben. Es gibt sogar Graphen, die sich auf keine Art und Weise ohne Überschneidungen von Kanten zeichnen lassen.


\section{Planare Graphen}

Da das Ziel des Algorithmus ist, Graphen ohne Überschneidungen zu zeichnen, stellt sich die Frage, ob es grundsätzlich möglich ist, alle Graphen überschneidungsfrei zu zeichnen oder welche Graphen sich nicht überschneidungsfrei zeichnen lassen.

\begin{figure}[h]
  \centering
  \includegraphics{nonplanar}
  \caption{Zwei Zeichnungen von Graphen, die sich nicht überschneidungsfrei zeichnen lassen.}
  \label{fig:nonplanar}
\end{figure}

\begin{definition}
  Ein Graph $G$ heißt \emph{planar}, wenn er in der Ebene ohne Überschneidungen gezeichnet werden kann.
\end{definition}

Hierbei dürften sich die Kanten an den Knoten berühren. Das der Beispielgraph $G_\text{E}$ planar ist, haben wir bereits bewiesen, indem wir ihn ohne Überschneidungen gezeichnet haben. 

Die Graphen aus Abbildung~\ref{fig:nonplanar} jedoch lassen sich nicht ohne Überschneidung zeichnen, sie sind nicht planar. Solche nicht-planaren Graphen werden wir nicht weiter behandeln. 

Für planare Graphen ist es nicht offensichtlich, wie genau sie gezeichnet werden müssen, damit sich keine Überschneidungen ergeben. Der eigentlich planare Beispielgraph $G_\text{E}$ wurde in Abbildung~\ref{fig:exampleAstraightlineNonplanar} mit Überschneidungen gezeichnet. 

Nach dem Satz von Fáry hat jeder planare Graphen eine Zeichnung, in der alle Kanten als gerade Linien gezeichnet sind. % TODO: ?

In dieser Zeichnung unterteilen die Kanten die Zeichenebene in abgegrenzte Bereiche, die \emph{Facetten}. Jede Kante grenzt an zwei Facetten, auf jeder Seite eine. Die beiden Knoten der Kante grenzen ebenfalls an die beiden Facetten. Der Bereich außerhalb, der den Graphen umgibt, heißt \emph{Außenfacette}.

Die Reihenfolge der Kanten um einen Knoten im Uhrzeigersinn in dieser Zeichnung, also eine Anordnung der Adjazenzlisten, ist auf dem Weg zur überschneidungsfreien Zeichnungen ausschlaggebend.


\begin{definition}
  Eine \emph{planare Einbettung} eines Graphen $G = (V, E)$ gibt für alle $v \in V$ eine Reihenfolge der Kanten der Adjazenzliste $A(v) = \{e_1, \dots, e_n\}$ vor.
\end{definition}

In der planaren Zeichnung des Graphen $G_\text{E}$ in Abbildung~ \ref{fig:exampleAstraightline} wären z.B. folgende Adjazentlisten-Reihenfolgen: $A(0) = \{4,1,2\}, A(1) = \{0,4,2\}, A(2) = \{0,1,4,3\}, A(3) = \{2,4\}, A(4) = \{3,2,1,0\}, $. Zyklische Verschiebungen dieser Listen sind äquivalent.

Planare Graphen haben die Eigenschaft, dass die Anzahl der Kanten die dreifache Anzahl der Knoten nicht überschreiten kann, genauer: $|E| \leq 3 |V| - 6$. Hat ein Graph mehr als $3 |V| - 6$ Kanten, können wir also ausschließen, dass er planar ist. Wenn Algorithmen auf planaren Graphen laufen, können durch $|E| = O(|V|)$ einige Operationen, die auf allgemeinen Graphen in $O(|V| + |E|)$ Zeit laufen, in linearer Zeit $O(|V|)$ laufen. Mit Hilfe dieser Eigenschaft können wir später die Laufzeit von Teilen unseres Algorithmus mit $O(|V|)$ angeben.

Wie in Abschnitt~\ref{sec:orthogonalDrawings} gezeigt, können in orthogonalen Zeichnungen nur solche Graphen überschneidungsfrei gezeichnet werden, deren Grad maximal~4 ist. Zusätzlich können nur planare Graphen überschneidungsfrei gezeichnet werden. Man nennt Graphen, die diese beiden Bedingungen erfüllen, auch \emph{4"~planar}.

\section{Zusammenhangs-Eigenschaften von Graphen}

\begin{definition}
  Ein \emph{Teilgraph} $G'$ eines Graphen $G=(V, E)$ ist ein Graph $G' = (V' \subset V, E' \subset E))$.
  Ein \emph{induzierter Teilgraph} $G_U$ eines Graphen $G=(V, E)$ über einer Menge $U \subset V$ ist der Kanten-Maximale Graph mit $G_U = (U , E' \subset E))$.
\end{definition}

Häufig werden nur Teile eines größeren Graphen betrachtet. % TODO: mehr?

\begin{definition}
  Ein \emph{Weg} ist ein Graph $G = (V, E)$ mit $V = \{v_1, v_2, \dots, v_n\}$ und $E = \{\{v_1, v_2\}, \{v_2, v_3\}, \dots, \{v_{n-1}, v_{n}\}\}$.
  Es gibt in einem Graphen $G = (V, E)$ einen Weg zwischen zwei Knoten $v_\text{a}, v_\text{a} \in V$, wenn es einen Teilgraphen von $G$, gibt, der ein Weg ist und $v_\text{a}$ und $v_\text{a}$ erhält.
  Ein Graph ist \emph{zusammenhängend}, falls es zwischen jeden zwei Knoten aus dem Graphen einen Weg gibt.
  Ist ein Graph nicht zusammenhängend, so nennt man die dispariten, maximalen zusammenhängenden Teilgraphen die \emph{Zusammenhangskomponenten}.
\end{definition}

Werden die Zusammenhangskomponenten einzeln gezeichnet, dann können sie unabhängig voneinander platziert werden: Zwei Zeichnungen von getrennten Zusammenhangskomponenten können beliebig nebeneinander gestellt werden. Ist in einer Teil-Zeichnung eine freie Fläche von der Größe einer anderen Teil-Zeichnung, könnten die kleine Zeichnung in der größeren Platz finden. Dies sind jedoch Optimierungsschritte, die unabhängig vom Zeichenalgorithmus der Komponenten sein können und auf die hier nicht weiter eingegangen wird.

\begin{definition}
  Man nennt zwei Knoten $v_\text{a}, v_\text{b} \in V$ in einem Graphen $G = (V, E)$ \emph{benachbart}, falls es eine Kante $e = \{v_\text{a}, v_\text{b}\}$ in $E$ gibt, und $v_\text{a}$ heißt in diesem Fall \emph{Nachbar} von $ v_\text{b}$ an $e$. 
\end{definition}

In dieser Sicht ist die reflexiv-transitive Hülle der Benachbart-Relation eine Äquivalenzrelation und ihre Äquivalenzklassen sind die Zusammenhangskomponenten des Graphen. %% TODO: Beweis?


\section{Zweifach-Zusammenhang und st-Ordnungen}

\begin{definition}
  Ein \emph{zweifach (knoten)zusammenhängender} Graph ist ein Graph $G=(V, E)$ für den jeder induzierte Teilgraph $G_{V \setminus v}$ für alle $v \in V$ zusammenhängend ist.
  Ist ein Graph $G=(V, E)$  nicht zweifach zusammenhängend, so nennt man die maximalen zweifach zusammenhängenden Teilgraphen die \emph{Zweifach-Zusammenhangskomponenten}. Die Zeugen $v \in V$, für die der induzierte Teilgraph $G_{V \setminus v}$ nicht zusammenhängend ist, nennt man \emph{Schnittknoten}. Kanten $e \in E$, für die $G' = (V, E \setminus e)$ nicht zusammenhängend ist, nennt man \emph{Brücken}.
\end{definition}

Ein Kreis ist ein zweifach zusammenhängender Graph, da durch Hinwegnahme eines Knotens ein zusammenhängender Weg entsteht. Ein Baum ist nicht zweifach knotenzusammenhängend, da durch Hinwegnahme der Wurzel, die Kinder nicht mehr zusammenhängend sind.

Die Zweifach-Zusammenhangskomponenten eines Graphen bilden einen Baum. Jede Kante liegt in genau einer Zweifach-Zusammenhangskomponente.

Ein zweifach zusammenhängender Graph ist die Grundlage für eine weiteres Element das Zeichenalgorithmus:

\begin{definition}
  Eine \emph{$st$-Ordnung} eines zweifach zusammenhängenden Graphen $G = (V, E)$ und zweier Knoten $s, t \in V$ ist eine Anordnung aller Knoten $v_1, v_2, \dots, v_n \in V$, sodass $s = v_1$, $t = v_n$ und alle Knoten $v_i$ außer $s$ und $t$  einen Nachbarn $v_j$ mit $j < i$ und einen Nachbarn $v_k$ mit $k > i$ haben.
\end{definition}

des Weiteren heißt der Knoten $s$ auch \emph{Quelle} und $t$ \emph{Senke}. Durch die $st$-Ordnung können die Knoten in eine Reihenfolge gebracht werden, in der sie der Algorithmus bearbeiten kann.

Die $st$-Ordnung hat in planaren Graphen noch eine weitere Eigenschaft, wenn man die planare Einbettung betrachtet. In der Adjazenzliste eines Knotens folgen sind Kanten, die zu einem Knoten mit höherer Zahl, in einem Block aufeinander, ebenso solche die zu einem Knoten mit niedriger Zahl führen. Es gibt also an jedem Knoten zwei Bündel von Kanten, die sich nicht überschneiden; eines mit Kanten zu höherwertigen Knoten und eines mit Kanten zu minderwertigen Knoten im Hinblick auf die $st$-Ordnung.

% Graph<=>Relation...?

\section{Glatt-orthogonale Zeichnungen}

Für das berechnen orthogonaler Zeichnungen sind viele Algorithmen bekannt. Hier geht es jedoch um eine interessante Variation von orthogonalen Zeichnungen: \emph{Glatt-orthogonale Zeichnungen} von Graphen nach Bekos~et.~al.~\cite{bekos-13}. Sie platzieren die Knoten, wie orthogonale Zeichnungen auch, auf einem Koordinatengitter und erlauben horizontale und vertikale Segmente. Zusätzlich enthalten sie jedoch Kreisbögen, die tangential in die geraden Segmente übergehen, wie in Abbildung~\ref{fig:anatomieLKante}. Sie in insofern "`glatt"', als dass sie keine Ecken in den Kanten haben, da die 90\textdegree"~Knicke durch Kreissegmente abgerundet sind.

\begin{figure}[h]
  \centering
  \includegraphics{anatomieLKante}
  \caption{Bezeichnungen in glatt-orthogonalen Zeichnungen anhand der L"~Kante: (i) oberer Knoten, (ii) 90\textdegree-Kreissegment, (iii) Knick, (iv) horizontales Liniensegment, (v) unterer Knoten.}
  \label{fig:anatomieLKante}
\end{figure}

Zwei Beispiele für glatt-orthogonale Zeichnungen finden sich in Abbildung~\ref{fig:exampleAsmooth}. In der Zeichnung~\ref{fig:exampleAsmoothSimple} fällt die lange Kante $\{0,4\}$ mit einem 270\textdegree-Kreissegment auf.

\begin{figure}[h]
  \centering
\begin{subfigure}[b]{0.3\textwidth}
  \centering
  \includegraphics{exampleA/smoothComplex}
  \caption{Mit Kante $\{0,4\}$ aus drei Segmenten.}
  \label{fig:exampleAsmoothComplex}
\end{subfigure}
  \quad
\begin{subfigure}[b]{0.6\textwidth}
  \centering
  \includegraphics{exampleA/smooth}
  \caption{Mit Kante $\{0,4\}$ aus zwei Segmenten.}
  \label{fig:exampleAsmoothSimple}
\end{subfigure}
  \caption{Der Graph $G_\text{E}$ aus Beispiel~\ref{ex:graph} in zwei glatt-orthogonalen Versionen der Zeichnung aus Abbildung~\ref{fig:exampleAorthogonalCompress}. Die Knickpunkte zwischen zwei Segmenten einer Kante sind als Kreuze eingezeichnet.}
  \label{fig:exampleAsmooth}
\end{figure}

Ebenso, wie bei orthogonalen Zeichnungen, gibt man die \emph{Komplexität} einer glatt-orthogonalen Zeichnung in Abhängigkeit der größten Anzahl von Segmenten $k$ in einer Kante dieser Zeichnung an, und nennt sie dann eine \emph{$\text{SC}_k$-Zeichnung}. Ein triviale Umwandlung einer orthogonalen Zeichnung in eine glatt-orthogonale Zeichnung wäre es, alle 90\textdegree-Knicke durch 90\textdegree-Kreissegmente mit dem Radius einer Gittereinheit zu ersetzen.

Konvertiert man die Kante $\{0,4\}$, wie sie in der OC$_3$-Zeichnung aus Abbildung~\ref{fig:exampleAorthogonalNocompress} zu sehen ist, auf diese Methode, erhielte man drei Segmente, zu sehen in der Zeichnung~\ref{fig:exampleAsmoothComplex}. Wäre das obere horizontale Segment etwas länger, erhielte man gar fünf Segmente, und somit wäre die resultierende Zeichnung von der Komplexität SC$_5$.

Benutzt man jedoch das große 270\textdegree-Kreissegment, schafft man es, die Anzahl der Segmente auf zwei zu reduzieren und man erhält eine SC$_2$-Zeichnung. Wir streben nun Zeichnungen mit möglichst niedriger Komplexität an. Es gibt nicht für alle 4"~planare Graphen eine SC$_1$-Zeichnung, und solche Zeichnungen haben u.U. einen vergleichsweise Großen Platzbedarf. Eine SC$_2$-Zeichnung ist jedoch stets möglich, wie anhand des Algorithmus zu sehen ist. Auch sie haben im Allgemeinen einen größeren Platzbedarf als die SC$_5$-Zeichnung der trivialen Umwandlung, dies ist jedoch ein Kompromiss, der für die geringere Kantenkomplexität eingegangen werden muss. % TODO: Proof? Elaborate? idk

Auch für SC$_2$ Zeichnungen ist es sinnvoll, das Aussehen der Kanten so zu normieren, dass die Angabe der Knotenpositionen und der Ports eine Zeichnung vollständig beschreibt.




\chapter{Algorithmus}
\label{chap:algo}

Nachdem nun im Grundlagen-Kapitel~\ref{chap:basics} die nötigen Begriffe definiert wurden, und darauf hingeführt wurde, welche Probleme der Algorithmus lösen muss und welche nicht, wird nun in diesem Kapitel der Algorithmus Schritt für Schritt erklärt.

\section{Übersicht}

Der Algorithmus erhält als Eingabe einen 4"~planaren, zweifach knotenzusammenhängenden Graphen. Die Ausgabe ist eine glatt-orthogonale SC$_2$ Zeichnung des Graphen.

Der Algorithmus berechnet zunächst eine planare Einbettung und eine $st$-Ordnung für den Graphen.

Damit eine Einbettung berechnet werden kann, muss der Graph planar sein. Die fertige Zeichnung wird die hier berechnete Einbettung widerspiegeln. Die planare Einbettung muss lediglich konsistente Sortierungen für die Adjazenzlisten liefern, ansonsten kann sie frei bestimmt werden. Aus der planaren Einbettung wird später die Reihenfolge der Kanten bei der Portzuweisung festgelegt.

Damit eine $st$-Ordnung berechnet werden kann, muss der Graph zweifach zusammenhängend sein. Der Unteralgorithmus zur Berechnung der $st$-Ordnung muss als Eingabe zwei Knoten $s$ und $t$ akzeptieren, die als Quelle und Senke verwendet werden. Die beiden Knoten müssen an die selbe Facette grenzen, diese wird in der Zeichnung die Außenfacette werden. Soll also eine bestimmte Facette die äußere werden, können die beiden Knoten entsprechend gewählt werden. Die resultierende $st$-Ordnung gibt die Reihenfolge an, in der die Knoten im nächsten Schritt platziert werden.

Auf Grundlage der $st$-Ordnung und der planaren Einbettung wird nun in drei Iterationen ein Layout als Vorgabe für die Zeichnung berechnet. 

Die erste Iteration erstellt ein orthogonales Layout für eine OC$_3$-Zeichnung. Es behält die planare Einbettung bei und platziert die Knoten in der von der st-Ordnung vorgegebenen Reihenfolge. Die hier festgelegten Portzuweisungen werden nun nicht mehr verändert, lediglich die Positionen der Knoten werden in den nächsten beiden Iterationen angepasst.

In der zweiten Iteration wird dieses Layout so verkleinert, dass stufenförmige Kanten zu horizontalen Linien konvertiert werden. während vorher alle Knoten eine unterschiedliche Höhen, also y"~Koordinaten, hatten, werden nun mehrere Knoten platzsparend auf einer Höhe untergebracht.

In der dritten Iteration wird das Layout für die OC$_3$-Zeichnung so angepasst, dass es auch als Layout für eine planare SC$_2$-Zeichnung dienen kann. Würde man direkt die glatt-orthogonalen Kanten einzeichnen, wäre die entstandene Zeichnung in vielen Fällen nicht planar. Darum müssen die Knoten so auseinandergezogen werden, dass genug Platz für die Kanten ist und sie überschneidungsfrei verlaufen, aber nicht gleichzeitig andere Kanten so verändert werden, dass sie wiederum neue Überschneidungen bilden.

Wenn das Layout für die SC$_2$-Zeichnung fertig ist, bleibt nur noch als letzter Schritt aus dem Layout eine Zeichnung herzustellen. Dazu muss aus den Portzuweisungen und den Positionen der Knoten relativ zueinander auf die Formen der Kanten geschlossen werden.

Nach Abschluss des letzten Schrittes erhält man eine glatt-orthogonale SC$_2$-Zeichnung des 4"~planaren, zweifach knotenzusammenhängenden Graphen. Die Schritte sind in Algorithmus~\ref{alg:biconnected} zusammengefasst.

\begin{algorithm}[ht]
  \SetKw{True}{true}
  \SetKw{False}{false}
  \caption{SmoothOrthogonalDrawBiconnected(Graph $G = (V,E)$)}
  \label{alg:biconnected}
  \Ein{4-planarer, zweifach knotenzusammenhängender Graph $G = (V,E)$}
  \Aus{$SC_2$-Layout von $G$}
  
  $\Epsilon \leftarrow$ CalculatePlanarEmbedding$(G)$ \;
  Wähle zwei Knoten $s, t \in V$ die in $\Epsilon$ an einer Facette liegen.\;
  $St \leftarrow$ CalculateStOrdering$(G, s, t)$ \;
  $O \leftarrow$ GenerateOrthogonalLayout$(G,St,\Epsilon)$ \;
  $O' \leftarrow$ EliminateS-Shapes$(O)$ \;
  $O'' \leftarrow$ EliminateCrossings$(O')$ \;
  $\Gamma \leftarrow$ DrawSmoothEdges$(O'')$ \;
  
  \Return $\Gamma$
\end{algorithm}

\section{Orientierte Graphen und Tiefensuche}

Eine algorithmische Grundlage, die im Verlauf des Algorithmus mehrmals verwendet wird, die \emph{Tiefensuche}. Sie wurde von Tarjan~\cite{tarjan-72} formalisiert. Konträr zum Namen werden jedoch oft keine Knoten gesucht, sondern vielmehr ein Tiefensuchenbaum konstruiert.

Bei der Tiefensuche wird der Graph orientiert. Ein \emph{orientierter Graph} eines Graphen $G = (V, E)$ weißt den Knoten jeder Kante eine Reihenfolge zu. Jede Kante $e \in E$ ist also ein geordnetes Paar $e = (v_\text{A}, v_\text{B})$ und die Kanten bekommen damit eine Richtung, sie zeigen von $v_\text{A}$ nach $v_\text{B}$. Man nennt $v_\text{A}$ \emph{Vorgänger} von $v_\text{B}$ und $v_\text{B}$ heißt Nachfolger von $v_\text{A}$. Die Kante ist eine \emph{ausgehende Kante} von $v_\text{A}$ und eine \emph{eingehende Kante} von $v_\text{B}$. Die Anzahl der ausgehenden Kanten eines Knotens heißt sein \emph{Ausgangsgrad}, analog gibt es den \emph{Eingangsgrad}.

Schon aus einer $st$-Ordnung könnte ein orientierter Graph gewonnen werden, indem die Kanten von einem Knoten mit höherer Zahl zu einem mit niedrigerer Orientiert werden. Die Tiefensuche liefert eine andere Orientierung.

Im Verlauf der Tiefensuche nach Algorithmus~\ref{alg:dfs} wird nicht nur ein orientierter Graph berechnet, jedem Knoten wird eine \emph{Auffindungszeit} zugeweisen, und eine Partition der Kanten $E = E_\text{T} \cup E_\text{R}$ wird erstellt. Man nennt die Kanten $e_\text{T} \in E_\text{T}$ \emph{Baumkanten} und die übrigen Kanten $e_\text{R} \in E_\text{R} =  E \setminus E_\text{T}$ \emph{Rückwärtskanten}. Die Baumkanten zeigen jeweils von einem Knoten mit niedrigerer Auffindungszeit zu einem mit höherer. Die Startknoten, die \emph{Wurzeln}, haben keine eingehende Baumkante, jeder andere Knoten hat genau eine. Die Rückwärtskanten zeigen jeweils von einem Knoten mit höherer Auffindungszeit zu einem mit niedrigerer. Das Tupel der beiden Mengen von gerichteten Kanten $(E_T, E_R)$ nennen wir \emph{Tiefensuchenbaum} (englisch \emph{palm tree}).

Im Algorithmus~\ref{alg:dfs} sind die Knoten, die in Zeile~\ref{alg:dfs:nl:connectedStart} behandelt werden Wurzeln, in Zeile~\ref{alg:dfs:nl:treeEdge} wird eine Kante orientiert und als Baumkante kategorisiert, in Zeile~\ref{alg:dfs:nl:backEdge} als Rückwärtskante.

\begin{algorithm}[ht]
  \SetKw{True}{true}
  \SetKw{False}{false}
  \SetKwBlock{Visit}{Visit(v)}{end}
  \caption{BuildPalmTree(Graph $G = (V,E)$)}
  \label{alg:dfs}
  \Ein{ungerichteter Graph $G = (V,E)$}
  \Aus{Tiefensuchenbaum $(E_T, E_R)$ von $G$}
\BlankLine
  $E_T \leftarrow \emptyset$, $E_R \leftarrow \emptyset$ \;
  \For{$v \in V$}{
    $v$.discoveryTime $\leftarrow \perp$ \;
  }
  $i := 0$ \;
\BlankLine
  \For{$v \in V$}{
    \If{$v$.discoveryTime == $\perp$}{
      Visit$(v)$ \; \nllabel{alg:dfs:nl:connectedStart}
    }
  }
\BlankLine
  \Visit{
    $v$.discoveryTime $\leftarrow i$ \; \nllabel{alg:dfs:nl:visitStart}
    $i \leftarrow i+1$ \;
    \For{$w \in A(v)$}{
      \If{$w$.discoveryTime == $\perp$}{ \nllabel{alg:dfs:nl:decide}
        $E_T \leftarrow E_T \cup \{(v, w)\}$ \; \nllabel{alg:dfs:nl:treeEdge}
        Visit(w) \; \nllabel{alg:dfs:nl:recur}
      }
      \Else{
        \If{$w$.discoveryTime < $v$.discoveryTime {\bf and}  $(v, w) \notin E_T$}{
          $E_R \leftarrow E_R \cup \{(v, w)\}$\; \nllabel{alg:dfs:nl:backEdge}
        }
      }
    }
  }
\BlankLine
    \Return\{$(E_T, E_R)$\}
\end{algorithm}

Die Tiefensuche ist so Grundlegend für viele der kommenden Algorithmen, da sie zu mehr als der Berechnung eines Tiefensuchenbaums verwendet werden kann, indem man entsprechende Zeilen einfügt. 

Beispielsweise die Zusammenhangskomponenten eines Graphen können bestimmt werden, da jedes mal, wenn Zeile \ref{alg:dfs:nl:connectedStart} erreicht wird, alle folgenden Knoten zu einer neuen Zusammenhangskomponente gehören. Ist ein Graph zusammenhängend, gibt es somit nur eine Wurzel.

Die Höhe eines Knotens im Tiefensuchenbaum ist die Länge des Weges von Baumkanten von der Wurzel zum Knoten. Sie kann im Verlauf der Tiefensuche mit abgespeichert werden, indem man vor Zeile~\ref{alg:dfs:nl:connectedStart} die Anweisung $v.$height $\leftarrow 0$ einfügt, und vor Zeile~\ref{alg:dfs:nl:recur} die Anweisung $w.$height $\leftarrow v.$height$ + 1$.


Für die Bestimmung von Zweifach-Zusammenhangskomponenten benötigt man das Konzept des \emph{Rückwegs}: Von einem Knoten $v$ kann man den Baumkanten zu Knoten mit höherer Auffindungszeit folgen. Von diesen Knoten können Rückwärtskanten ausgehen, die mitunter zu Knoten mit einer kleineren Auffindungszeit als der von $v$ führen. Den Knoten mit der niedrigsten Auffindungszeit, den wir auf diese Weise vom Knoten $v$ erreichen können, nennen wir \emph{Rückpunkt}. Hat ein Knoten sich selbst als Rückpunkt, kann also kein niedrigerer Knoten erreicht werden, so ist er Trenner von Zweifach-Zusammenhangskomponenten.

Die Rückpunkte können während der Tiefensuche bestimmt werden. Wenn ein Knoten $v$ besucht wird, also in Zeile~\ref{alg:dfs:nl:visitStart}, speichern wir zunächst den Knoten $v$ selbst als Rückpunkt. Wird in Zeile~\ref{alg:dfs:nl:backEdge} eine Rückwärtskante von $v$ nach $w$ gefunden, so wird geprüft ob $w$ niedriger ist als der bisherige Rückpunkt von $v$ und, wenn ja, wird der Rückpunkt von $v$ auf $w$ gesetzt. Nach der Rückkehr vom rekursiven Aufruf in Zeile~\ref{alg:dfs:nl:recur} wird geprüft, ob der Knoten $w$ nun einen echt niedrigen Rückpunkt als $v$ hat, wenn ja, wird der Rückpunkt von $v$ auf den Rückpunkt von $w$ gesetzt.

Beim Berechnen der planaren Einbettung und der st-Ordnung werden Rückpunkte und Rückwege verwendet.

\section{Bestimmung einer planaren Einbettung}

Da am Ende eine planare Zeichnung entstehen soll, wird zuerst eine planare Einbettung berechnet. Hierbei wird auch geprüft, ob der Graph überhaupt planar ist, d.h. ob es möglich ist eine planare Einbettung zu erstellen. 

Zum Prüfen auf Planaritätseigenschaft gibt es diverse Algorithmen, die bei Patrignani~\cite{patrignani-07} vorgestellt und verglichen werden. Der erste effiziente Linearzeit-Algoritmus wurde von Hopcroft und Tarjan~\cite{hopcroft+tarjan-74} veröffentlicht, jedoch ist er sehr schwer zu implementieren, somit wurde für die Implementierung nach einer Alternative gesucht. Dass dann der Links-Rechts-Planaritätstest wie von Brandes~\cite{brandes-09} beschrieben ausgewählt wurde, begründet sich mit zweierlei Abwägungen. Zum einen ist es wichtig, dass nicht nur die Planarität getestet wird, sondern auch eine planare Einbettung angegeben werden kann, damit diese für das Zeichnen zur Verfügung steht. Dies wurde bei \cite{brandes-09} mittels vergleichsweise geringem Aufwand realisiert. Zum anderen liefert \cite{brandes-09} eine Beschreibung, die eine Implementierung begünstigt, da zu den Schritten sehr detaillierter Pseudocode angegeben wird. % TODO: citations like this?

Für den Planaritätstest wird zunächst ein Tiefensuchenbaum $(E_T, E_R)$ des Eingabegraphen erstellt. Die Grundidee ist es, die Rückwärtskanten aus $E_\text{R}$ in zwei disjunkte Teilmengen $L$ und $R$, für Links und Rechts, einzuteilen. Betrachten wir nun einen Knoten $v \in V$ und zwei Baumkanten $(v, v_1), (v, v_2) \in E_T$. Nun sollen alle Kanten, die am Ende eines Rückwegs von $v_1$ aus liegen und echt höher enden als der Rückpunkt von $v_2$ zu einer Teilmenge gehören. Gleichzeitig sollen alle Kanten, die am Ende eines Rückwegs von $v_2$ aus liegen und echt höher enden als der Rückpunkt von $v_1$ zur jeweils anderen Teilmenge gehören. Der Graph ist genau dann planar, wenn eine solche Partition möglich ist. Die planare Einbettung erhält man, wenn man die Baumkanten hinzu nimmt und geeignet mit den Rückwärtskanten in eine Reihenfolge der Adjazenzliste bringt.

Die so bestimmten geordneten Adjazenzlisten werden dann beim erstellen des Layouts für die OC$_3$-Zeichnung verwendet.

\section{Ermitteln einer $st$-Ordnung}

Neben dem Graphen selbst und der planaren Einbettung benötigt der Schritt, in dem das OC$_3$-Layout erstellt wird eine st-Ordnung, eine Reihenfolge der Knoten $v_1, \dots, v_n$, mit $s=v_1$ und $t=v_n$, in der die Knoten dann platziert werden. 

Jeder Knoten, außer $s$ und $t$, soll mindestens einen Nachbarn mit einem höheren Index und mindestens einen mit einem niedrigeren Index haben. Da die Indizes paarweise verschieden sind, erhalten wir zudem einen orientierten Graphen, wenn wir die ungerichteten Kanten so ausrichten, dass sie vom niedrigeren Index zum höheren verlaufen.

Die $st$-Ordnung soll mir der planaren Einbettung kompatibel sein, d.h. wir wählen zwei Knoten $s$ und $t$ auf der Außenfacette. Damit haben wir eine günstige Reihenfolge für die Platzierung der Knoten bei der Berechnung des Layouts. 

Eine solche $st$-Ordnung lässt sich mit einer angepassten Tiefensuche und einer passenden Nachbearbeitung für jeden zweifach zusammenhängenden Graphen ermitteln. Ein Beweis in Form eines Linearzeit-Algortihmus findet sich bei Even und Tarjan~\cite{even+tarjan-75}, basierend auf vorherigen Resultaten (\cite{hopcroft+tarjan-74},~\cite{tarjan-72}).

Die Tiefensuche wird so angepasst, dass jedes Mal, wenn wir den Rückpunkt eines Knotens $v$ aktualisieren, die aktuelle Kante als zugehörig zum Rückweg des Knotens $v$ speichern.

Der Nachbearbeitungsschritt speichert zu jeder Kanten und jedem Knoten, ob sie/er schon abgearbeitet wurde. Er fügt die Knoten in der Reihenfolge der $st$-Ordnung zu einer Ergebnisliste hinzu. Er legt dazu $t$ unter $s$ auf einen Stack. Solange der Stack nicht leer ist, wird wiederholt ein Knoten $v$ herunter genommen. Es wird nun ein Pfad vom Knoten $v$ aus gesucht, der noch nicht abgearbeitete Kanten benutzt, um zu einem bereits abgearbeiteten Knoten zu gelangen. Wird so ein Pfad gefunden, so werden die Knoten entlang des Pfades auf den Stack gelegt, ganz unten der vorletzte Knoten des Pfades bis zuletzt ganz oben $v$ abgelegt wird. Wird kein solcher Pfad gefunden, so wird $v$ an die Ergebnisliste angehängt und ist nun nicht mehr auf dem Stack.

Für das finden eines Pfades gibt es drei Möglichkeiten, die der Reihe nach ausprobiert werden. Gibt es eine nicht abgearbeitete, ausgehende Rückwärtsecke, so ist diese der Pfad. Gibt es ansonsten eine nicht abgearbeitete Baumkante, so wird dieser gefolgt und dann dem Rückweg des Zielknotens, bis er auf einen abgearbeiteten Knoten trifft. Gibt es nur noch eine nicht abgearbeitete eingehende Rückwärtskante, so  wird dieser gefolgt und dann den Baumkanten zurück bis zu einem abgearbeiteten Knoten. Die Knoten und Kanten des Pfades werden als abgearbeitet markiert. Gibt es nur noch abgearbeitete Kanten, wird kein Weg gefunden.

Zuletzt stehen in der Ergebnisliste die Knoten in der Reihenfolge einer $st$-Ordnung.

\section{Erstellung eines $OC_3$-Layouts}

\cite{liu+etal-98} \cite{biedl+kant-98}

Für die Erstellung des $OC_3$-Layouts erhalten wir die Knoten in der Reihenfolge der $st$-Ordnung $v_1, \dots, v_n$. Durch die st-Ordnung erhalten wir zudem gerichtete Kanten und die Knoten haben somit einen Eingangsgrad und einen Ausgangsgrad, die sich, wegen der 4"~Planariät, zu maximal 4 addieren. Außer $v_1$ und $v_n$ liegt bei den Knoten der Eingangsgrad und der Ausgangsgrad zwischen 1 und 3, da sie mindestens eine eingehende und mindestens eine ausgehende Kante haben. Die planare Einbettung $E$ gibt uns an jedem Knoten eine Reihenfolge der Kanten zu den adjazenten Knoten an. Ein- und Ausgehende Kanten liegen hierbei in zwei Abschnitten jeweils zusammen beieinander.

Am Ende bekommt jeder Knoten eine x-Koordinate (Spalte) und eine y"~Koordinate (Zeile). Da wir die x"~Koordinaten sonst häufig anpassen müssten, ordnen wir den Knoten zunächst nur Spalten zu. So können wir eine neue Spalte dazwischen einfügen, ohne die Koordinaten sämtlicher Knoten in den Spalten danach zu erhöhen. 

Neben den Knoten positionieren wir ebenso \emph{offene Kanten} in den Spalten: Alle Kanten, die gezeichnet werden, haben ein horizontales Segment, dessen Position in einer Spalte vorgemerkt wird. Das Ende der Kante wird hierbei noch nicht festgelegt. % TODO: Offene Kante definieren

Für die Erstellung des $OC_3$-Layouts werden die Knoten in der Reihenfolge der st-Ordnung auf einem Gitter platziert. Die y"~Koordinate wird später nicht mehr benötigt und kann stets als $y(v_i) = i$ angenommen werden. Der erste Knoten wird in einer neuen, noch leeren Spalte platziert. Alle weiteren Knoten werden in der zugewiesenen Spalte der Kante an ihrem unteren Port platziert. Dazu müssen zunächst die Kanten den Ports zugewiesen werden.

\begin{figure}[h]
        \centering
        \subcaptionbox{1\label{fig:embedindeg1}}
            {\includegraphics[scale=.8]{oc2_embed/incoming/indeg1}}
        \quad
        \subcaptionbox{2\label{fig:embedindeg2}}
            {\includegraphics[scale=.8]{oc2_embed/incoming/indeg2}}
        \quad
        \subcaptionbox{3\label{fig:embedindeg3}}
            {\includegraphics[scale=.8]{oc2_embed/incoming/indeg3}}
        \quad
        \subcaptionbox{4\label{fig:embedindeg4}}
            {\includegraphics[scale=.8]{oc2_embed/incoming/indeg4}}

        \caption{Die Portzuweisung der bisher offenen Kanten je nach Eingangsgrad. Dick gezeichnet sind die eingehenden Kanten, gestrichelte Kanten sind mögliche Positionen von Ausgehenden Kanten.}
        \label{fig:embedin}
\end{figure}

Für die eingehenden Kanten werden, wie in Abbildung~\ref{fig:embedin} gezeigt, je nach Eingangsgrad des Knotens folgende Ports verwendet: Unten (1-4), links (2-4), rechts (3,4), oben (4). Der obere Port wird also nur bei Eingangsgrad 4 verwendet, was nur bei der Senke $v_n$ vorkommen kann. Der untere Port wird nur bei Eingangsgrad 0 nicht verwendet, was nur bei der Quelle $v_1$ vorkommt. Den Ports werden dann die Kanten nach der Reihenfolge der planaren Einbettung in der Abfolge oben, links, unten, rechts zugewiesen.

\begin{figure}[h]
        \centering
        \subcaptionbox{0\label{fig:embedoutdeg0}}
            {\includegraphics[scale=.8]{oc2_embed/outgoing/outdeg0}}
        \quad
        \subcaptionbox{1\label{fig:embedoutdeg1}}
            {\includegraphics[scale=.8]{oc2_embed/outgoing/outdeg1}}
        \quad
        \subcaptionbox{2\label{fig:embedoutdeg2}}
            {\includegraphics[scale=.8]{oc2_embed/outgoing/outdeg2}}
        \quad
        \subcaptionbox{3\label{fig:embedoutdeg3}}
            {\includegraphics[scale=.8]{oc2_embed/outgoing/outdeg3}}
        \quad
        \subcaptionbox{4\label{fig:embedoutdeg4}}
            {\includegraphics[scale=.8]{oc2_embed/outgoing/outdeg4}}

        \caption{Die Portzuweisung der neuen offenen Kanten und die neuen Spalten je nach Ausgangsgrad. Dick gezeichnet sind die ausgehenden Kanten, schraffierte Abschnitte stellen bisher gezeichnete Teile des Graphen dar.}
        \label{fig:embedout}
\end{figure}

Für die ausgehenden Kanten werden, wie in Abbildung~\ref{fig:embedout} gezeigt, je nach Eingangsgrad des Knotens folgende Ports verwendet: oben (1-4), rechts (2-4), links (3,4), unten (4). Der untere Port wird also nur bei Eingangsgrad 4 verwendet, was nur bei der Quelle $v_1$ vorkommen kann. Den Ports werden dann die Kanten nach der Reihenfolge der planaren Einbettung in der Abfolge oben, links, unten, rechts zugewiesen. 
Für die Kante des oberen Ports wird ein Kantenort in der Spalte des Knotens vermerkt. Für die Kanten der Ports links und rechts werden jeweils Kantenorte in neuen Spalten links und rechts des Knotens vermerkt. Gibt es eine Kante im unteren Port, bekommt sie einen Knotenort in einer weiteren neuen Spalte weiter rechts. % TODO: schwammig

Ist der Algorithmus bei $v_n$ angekommen, sind alle Knoten eingebettet. Zuletzt nummerieren wir die Spalten durch und weisen den darin platzierten Knoten diese Nummer als x"~Koordinate zu. 

\section{Eliminierung der stufenförmigen Kanten}

Das im letzten Schritt erstellte $OC_3$-Layout ist nicht sehr kompakt, da jeder Knoten in einer eigenen Zeile platziert ist. Außerdem sollen stufenförmige Kanten entfernt werden.

Zwei Knoten $v_i, v_k$ mit $i < k$ sind mit einer stufenförmigen Kante verbunden, wenn es eine Kante gibt, die am rechten Port von $v_i$ und am linken Port von $v_k$ ist. Solche Knoten nennen wir äquivalent bezüglich der Höhe und fassen gleich hohe Knoten in Äquivalenzklassen zusammen.

Diese Äquivalenzklassen verwenden wir als Knoten eines neuen gerichteten Graphen. Wir setzen eine gerichtete Kante zwischen zwei Äquivalenzklassen falls es eine gerichtete Kante zwischen zwei Knoten dieser Klasse gibt. Im so erhaltenen Graphen weisen wir der Klasse $\{v_1\}$ die Höhe~$1$ zu. Dann weisen wir allen anderen Klassen jeweils die um~1 inkrementierte Höhe ihres höchsten Vorgängers zu, bis alle Klassen eine Höhe erhalten haben. Zuletzt weisen wir den Knoten die Höhe ihrer Klasse als y"~Koordinate zu.

Offensichtlich kann es nun keine stufenförmigen Kanten mehr geben, da die entsprechenden Knoten in der gleichen Klasse sind. Die Transformation wurde in Abbildung~\ref{fig:exampleAorthogonalCompress} durchgeführt.

\section{Konvertierung in ein $SC_2$-Layout}



\section{Entfernen von Überschneidungen im $SC_2$-Layout}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth]{cut_L_slope_correction}
  \caption{Finden eines Schnittes zum Trennen des Graphen in eine linke und einer rechte Seite. Die linke Seite und der untere Knoten können frei nach links verschoben werden, um die Steigung der L"~Kante zu korrigieren. In Schraffur dargestellte Blöcke stehen für nicht weiter spezifizierte Teile des Graphen in der Zeichnung.}
  \label{fig:cutLslopecorrection}
\end{figure}






\chapter{Implementierung}

\section{Software}

Für die Implementierung in der Programmiersprache \emph{Java} wurde, wo möglich, auf bestehende und bewährte Software-Grundlagen gesetzt.

Das Ausgangsformat, aus dem die Graphen eingelesen wurde, ist \emph{GraphML}~\cite{brandes+al-14}. Das freie Datenformat ist das Ergebnis von Bemühungen, ein Standardisiertes Format für das Speichern von Graphen zu schaffen. Es basiert auf XML, kann alle Arten von Graphen speichern und ist zudem um eigene Attribute erweiterbar, diese Erweiterungen können beim Einlesen übersprungen werden.

Die Eingabedaten für die Graphen stammen größtenteils aus den \emph{Rom-Testgraphen}\footnote{Erhältlich unter \url{http://www.graphdrawing.org/data/}}, eine Sammlung von verschiedensten Graphen mit 10 bis 100 Knoten im GraphML-Format. Für das schelle Erstellen von Testgraphen für einige Spezialfälle wurde der Grapheneditor \emph{yEd}\footnote{Erhältlich unter \url{http://www.yworks.com/de/products_yed_about.html}} von yWorks verwendet, der ebenfalls das GraphML-Format unterstützt und Graphen übersichtlich visualisieren kann.

Zum Einlesen der Graphen in Java und ihre Repräsentation im Speicher wurde \emph{JUNG}~\cite{jung}\footnote{Erhältlich unter \url{http://jung.sourceforge.net/}}, das \emph{Java Universal Network/Graph Framework}, verwendet. Es beinhaltet neben effizienten Implementierungen von verschiedenen Graphen, etwa gerichtete und ungerichtete, einige Algorithmen auf Graphen und Werkzeuge zur Visualisierung. Außerdem lassen sich damit GraphML-Dateien einlesen.

Die Ausgabe der fertigen Zeichnungen erfolgte im Vektorgrafik-Format des Editors \emph{Ipe}\footnote{Erhältlich unter \url{http://ipe7.sourceforge.net/}}. Das Format basiert auf XML und erhält Möglichkeiten für das Zeichnen von Punkten, Linien und Kreisbögen und vielem mehr. Der Vorteil gegenüber anderen Vektorformaten ist, dass sich \LaTeX-Beschriftungen in den Zeichnungen platzieren lassen und die Zeichnungen in PDF-Dateien konvertiert werden können. Die fertigen Zeichnungen können mit dem Ipe-Editor annotiert und weiter bearbeitet werden.

Zum Erstellen der Ipe-Dateien aus Java wurde die \emph{IpeDraw-Bibliothek}\footnote{Erhältlich unter \url{http://lamut.informatik.uni-wuerzburg.de/mediawiki/ipe7/index.php/JAVAtoIPE}} von Philipp Kindermann und Martin Fink verwendet.

Es wurden also Daten aus dem Rom-Testgraphen entnommen oder direkt in yEd erstellt, in Java mittels JUNG eingelesen, durch den Algorithmus visualisiert und mit der IpeDraw-Bibliothek als Vektorgrafiken ausgegeben, welche im Ipe-Editor betrachtet werden können oder in PDFs konvertiert werden.

\section{Schnitte finden}

\begin{figure}[h]
        \centering
        \begin{subfigure}[b]{0.2\textwidth}
                \includegraphics[width=0.5\textwidth]{schnitt_finden/top_none}
                \caption{Oberhalb,\\ keine Kante}
                \label{fig:cutfinding_top_none}
        \end{subfigure}%
        \quad
        \begin{subfigure}[b]{0.2\textwidth}
                \includegraphics[width=\textwidth]{schnitt_finden/top_upwards}
                \caption{Oberhalb, Kante \\ nach oben}
                \label{fig:cutfinding_top_upwards}
        \end{subfigure}
        \quad
        \begin{subfigure}[b]{0.2\textwidth}
                \includegraphics[width=\textwidth]{schnitt_finden/top_downwardsL}
                \caption{Oberhalb, L"~Kante \\ nach unten}
                \label{fig:cutfinding_top_downwardsL}
        \end{subfigure}
        \quad
        \begin{subfigure}[b]{0.2\textwidth}
                \includegraphics[width=\textwidth]{schnitt_finden/top_downwardsC}
                \caption{Oberhalb, C"~Kante \\ nach unten}
                \label{fig:cutfinding_top_downwardsC}
        \end{subfigure}
        \quad
        \begin{subfigure}[b]{0.2\textwidth}
                \includegraphics[width=\textwidth]{schnitt_finden/bot_aboveL}
                \caption{Unterhalb, über eine \\ L"~Kante}
                \label{fig:cutfinding_bot_aboveL}
        \end{subfigure}
        \quad
        \begin{subfigure}[b]{0.2\textwidth}
                \includegraphics[width=0.25\textwidth]{schnitt_finden/bot_vertical}
                \caption{Unterhalb, entlang einer vertikalen Kante}
                \label{fig:cutfinding_bot_vertical}
        \end{subfigure}
        \quad
        \begin{subfigure}[b]{0.2\textwidth}
                \includegraphics[width=\textwidth]{schnitt_finden/bot_belowL}
                \caption{Unterhalb, \\ unter eine \\ L-Kante}
                \label{fig:cutfinding_bot_belowL}
        \end{subfigure}
        \caption{Die verschiedenen Fälle beim Finden eines Schnitts.}\label{fig:cutfinding}
\end{figure}


Das Finden eines Schnittes durch die Zeichnung des Graphen zum Zwecke des Verschiebens von Knoten in horizontale Richtung zielt darauf ab, den Graph in zwei Teile zu spalten, die nur durch horizontale Segmente verbunden sind. 

Der Schnitt beginnt oberhalb eines Knotens, entweder knapp links oder knapp rechts davon. Er setzt sich dann durch die Zeichnung fort und folgt dabei Kanten abwärts von Knoten zu Knoten. Dabei kann er Kanten an horizontalen Segmenten durchqueren.

Hierbei ergeben sich einige verschiedene Fälle, die in Abbildung~\ref{fig:cutfinding} dargestellt sind. Hier wird jeweils der Fall, dass der Schnitt auf der linken Seite eines Knotens $v$ beginnt, betrachtet, der andere Fall wird symmetrisch behandelt. 

Soll der Schnitt leicht oberhalb eines Knotens $v$ beginnen, so muss die Kante am linken Port betrachtet werden.

Ist dort keine Kante vorhanden, kann der Schnitt direkt zur leicht unterhalb Position am gleichen Knoten $v$ fortfahren.

Ist dort eine nach oben führende Kante oder eine horizontale gerade Kante, so durchquert der Schnitt die Kante. Nach den Invarianten ist immer ein horizontales Segment an dieser Stelle. Der Schnitt verbleibt am Knoten $v$ und ist nun leicht unterhalb von $v$. Führt die Kante am linken Port nach unten, so muss es entweder eine L- oder eine C"~Kante sein, in beiden Fällen folgt der Schnitt der Kante zum Zielknoten $u$. Die L"~Kante endet am Zielknoten $u$ am oberen Port und der Schnitt endet links oberhalb des Zielknotens. Die C"~Kante endet am Zielknoten $u$ am linken Port und der Schnitt endet links unterhalb.

Soll der Schnitt leicht unterhalb eines Knotens $v$ beginnen, so muss die Kante am unteren Port betrachtet werden. Endet die Kante an $u$ an einem rechten Port, so muss sie durchquert werden, und der Schnitt endet leicht rechts unterhalb des Zielknotens $u$. Ansonsten folgt der Schnitt der Kante. Endet die Kante an einem oberen Port, ist folglich eine gerade Kante, so endet der Schnitt leicht links oberhalb des Zielknotens. Endet die Kante an einem linken Port, liegt eine L"~Kante vor und der Schnitt endet leicht links unterhalb des Zielknotens.

Für den Fall, dass der Schnitt leicht rechts eines Knotens beginnt, sind jeweils rechts und links in den Schritten und Bedingungen zu tauschen.

Nach wiederholter Anwendung dieser Regeln, wobei jeweils der Zielknoten zum neuen Ausgansknoten wird, gelangt der Schnitt schließlich zur Position leicht unterhalb eines Knotens, der keine Kante am unteren Port hat. Dies ist der unterste Knoten, und der Schnitt ist abgeschlossen.

Die Konstruktion des Schnittes speichert bei jedem Durchqueren einer Kante die Kante selbst, und den Knoten links und rechts der Kante jeweils in einer Liste von linken und rechten Knoten. Zum finden der gesamten linken Knoten wird an jedem der Knoten in der Liste der linken Knoten eine Tiefensuche begonnen, die jedoch nicht den durchschnittenen Kanten folgt. Ebenso findet man die rechten Knoten, indem man bei allen rechten Knoten startet und wiederum durchschnittene Kanten ignoriert.

\chapter{Verbesserungen}

% veränderte slope korrektur
% sets auf gleicher höhe

% selten überhaupt kollisionen: 110/844

% selten muss wirklich L slope angepasst werden, macht aber viel (!!!) größer (richtung OS_1, erklären)
% ohne L-slope anpassung: 1/844 collisionen

% --> use adjustments only when necessary
% --> use them to reduce edge complexity?

% keinmal mehr als 3 in einer Reihe
% spezialfall mit 1 in Reihe, hin-her-Problem

% Problem mit unnötiger C-Anpasung

Nicht planare Graphen können durch ein einfaches Verfahren in planare Graphen umgewandelt werden: In einer zufälligen Zeichnung fügt man Knoten an allen Schnittpunkten von zwei Kanten ein. Beim Zeichnen lässt man die neuen Knoten weg.


\chapter{Schlussfolgerungen}

% Ausblick nicht-BC etc.




\bibliographystyle{mybabalpha-fl}
\bibliography{mybib}

\end{document}
